// Unsure on robustness as this was generated by Copilot, but may serve as the base for a future base implementation
pub struct Point {
    x: f64,
    y: f64,
}

pub struct AABB {
    center: Point,
    half_dimension: f64,
}

impl AABB {
    pub fn contains_point(&self, point: &Point) -> bool {
        let left = self.center.x - self.half_dimension;
        let right = self.center.x + self.half_dimension;
        let top = self.center.y - self.half_dimension;
        let bottom = self.center.y + self.half_dimension;

        point.x >= left && point.x <= right && point.y >= top && point.y <= bottom
    }

    pub fn intersects_aabb(&self, other: &AABB) -> bool {
        // Check if two AABBs overlap
        (self.center.x - self.half_dimension < other.center.x + other.half_dimension) &&
        (self.center.x + self.half_dimension > other.center.x - other.half_dimension) &&
        (self.center.y - self.half_dimension < other.center.y + other.half_dimension) &&
        (self.center.y + self.half_dimension > other.center.y - other.half_dimension)
    }
}

pub struct Quadtree {
    boundary: AABB,
    points: Vec<Point>,
    north_west: Option<Box<Quadtree>>,
    north_east: Option<Box<Quadtree>>,
    south_west: Option<Box<Quadtree>>,
    south_east: Option<Box<Quadtree>>,
}

impl Quadtree {
    pub fn new(boundary: AABB) -> Self {
        Self {
            boundary,
            points: Vec::new(),
            north_west: None,
            north_east: None,
            south_west: None,
            south_east: None,
        }
    }

    pub fn insert(&mut self, point: Point) -> bool {
        if !self.boundary.contains_point(&point) {
            return false;
        }

        if self.points.len() < 4 {
            self.points.push(point);
            return true;
        }

        if self.north_west.is_none() {
            self.subdivide();
        }

        if self.north_west.as_mut().unwrap().insert(point) {
            return true;
        }
        if self.north_east.as_mut().unwrap().insert(point) {
            return true;
        }
        if self.south_west.as_mut().unwrap().insert(point) {
            return true;
        }
        if self.south_east.as_mut().unwrap().insert(point) {
            return true;
        }

        false
    }

    fn subdivide(&mut self) {
        let hx = self.boundary.half_dimension / 2.0;
        let cx = self.boundary.center.x;
        let cy = self.boundary.center.y;

        let nw = AABB { center: Point { x: cx - hx, y: cy - hx }, half_dimension: hx };
        self.north_west = Some(Box::new(Quadtree::new(nw)));

        let ne = AABB { center: Point { x: cx + hx, y: cy - hx }, half_dimension: hx };
        self.north_east = Some(Box::new(Quadtree::new(ne)));

        let sw = AABB { center: Point { x: cx - hx, y: cy + hx }, half_dimension: hx };
        self.south_west = Some(Box::new(Quadtree::new(sw)));

        let se = AABB { center: Point { x: cx + hx, y: cy + hx }, half_dimension: hx };
        self.south_east = Some(Box::new(Quadtree::new(se)));
    }

    pub fn query_range(&self, range: &AABB) -> Vec<Point> {
        if !self.boundary.intersects_aabb(range) {
            return Vec::new();
        }

        let mut points_in_range = self.points.iter().filter(|p| range.contains_point(p)).cloned().collect::<Vec<Point>>();

        if self.north_west.is_some() {
            points_in_range.append(&mut self.north_west.as_ref().unwrap().query_range(range));
            points_in_range.append(&mut self.north_east.as_ref().unwrap().query_range(range));
            points_in_range.append(&mut self.south_west.as_ref().unwrap().query_range(range));
            points_in_range.append(&mut self.south_east.as_ref().unwrap().query_range(range));
        }

        points_in_range
    }
}